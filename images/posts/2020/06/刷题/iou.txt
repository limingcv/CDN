def get_iou(pred_bbox, gt_bbox):
	ixmin = max(pred_bbox[0], gt_bbox[0])
	iymin = max(pred_bbox[1], gt_bbox[1])
	ixmax = min(pred_bbox[2], gt_bbox[2])
	iymax = min(pred_bbox[3], gt_bbox[3])
	
	iw = np.maximum(ixmax - ixmin + 1., 0.)
	ih = np.maximum(iymax - iymin + 1., 0.)
	
	intersection = iw * ih
	
	union = (pred_bbox[2] - pred_bbox[0] + 1.) * (pred_bbox[3] - pred_bbox[1] + 1.)
		 + (gt_bbox[2] - gt_bbox[0] + 1.) * (gt_bbox[3] - gt_bbox[0] + 1.)
		  - intersection
	
	overlaps = intersection / union
	
	return overlaps

def nms(detections, threshold):
	x1 = detections[:, 0]
	y1 = detections[:, 1]
	x2 = detections[:, 2]
	y2 = detections[:, 3]
	scores = detections[:, 4]

	areas = (x2 - x1 + 1.) * (y2 - y1 + 1.)
	
	order = scores.argsort()[::-1]
	keep = []
	
	while order.size > 0:
		i = order[0]
		keep.append(i)

		ixmin = np.maximum(x1[i], x1[order[1:]])
		iymin = np.maximum(y1[i], y1[order[1:]])
		ixmax = np.minimum(x2[i], x2[order[1:]])
		iymax = np.minimum(y2[i], y2[order[1:]])
		
		iw = np.maximum(ixmax - ixmin + 1., 0)
		ih = np.maximum(iymax - iymin + 1., 0)
		
		intersections = iw * ih
		overlaps = intersections / (areas[i] + areas[order[1:]] - intersection)
		
		indices = np.where(overlaps >= threshold[0])
		
		order = order[indices + 1]
	
	return keep
